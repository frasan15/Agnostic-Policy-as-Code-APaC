- name: Provision an infrastructure on OpenStack # for some reason the floating ip is assigned automatically with this task
  hosts: localhost
  tags: ['deploy']
  tasks:
  - name: Create a network
    # Create an externally accessible network named 'ext_network'.
    openstack.cloud.network:
      state: present
      name: network1
      external: false

  - name: Create a subnet
  # Create a new (or update an existing) subnet on the specified network
    openstack.cloud.subnet:
      state: present
      network_name: network1
      name: subnet1
      cidr: 192.168.111.0/24
    register: subnet_info

  - name: Create (or update) a security group with security group rules
    openstack.cloud.security_group:
      state: present
      name: secgroup_1
      security_group_rules:
        - ether_type: IPv4
          direction: ingress
          description: Expose port 80
          protocol: tcp
          port_range_min: 80
          port_range_max: 80
          remote_ip_prefix: 0.0.0.0/0

  - name: Create (or update) a security group with security group rules
    openstack.cloud.security_group:
      state: present
      name: secgroup_2
      security_group_rules:
        - ether_type: IPv4
          direction: ingress
          description: Expose port 22
          protocol: tcp
          port_range_min: 22
          port_range_max: 22
          remote_ip_prefix: 0.0.0.0/0
  
# Create a port with a static IP for server1
  - name: Create a network inteface for server1
    openstack.cloud.port:
      state: present
      name: port_server_1
      network: network1
      fixed_ips:
        - ip_address: 192.168.111.10
          subnet_id: "{{ subnet_info.id }}"

# Create a port with a static IP for server2
  - name: Create a network inteface for server2
    openstack.cloud.port:
      state: present
      name: port_server_2
      network: network1
      fixed_ips:
        - ip_address: 192.168.111.11
          subnet_id: "{{ subnet_info.id }}"

# Remember to restart the vm if you change any environment variables
  - name: Deploy an instance
    openstack.cloud.server:
      state: present
      name: server1
      image: db1bc18e-81e3-477e-9067-eecaa459ec33
      key_name: MySecondKey
      timeout: 200
      flavor: gx1.2c4r
      nics:
        - port-name: port_server_1
      security_groups: secgroup_1
    register: instance

  # Creates a router attached to ext_network1 on an IPv4 subnet and with one
# internal subnet interface.
  - name: Create a router
    openstack.cloud.router:
      state: present
      name: router1
      network: 730cb16e-a460-4a87-8c73-50a2cb2293f9
      interfaces:
        - net: network1
          subnet: subnet1
          portip: 192.168.111.15 

  - name: Assign a floating ip
    openstack.cloud.floating_ip:
      state: present
      reuse: true
      server: server1
      network: 730cb16e-a460-4a87-8c73-50a2cb2293f9
      fixed_address: 192.168.111.10
      wait: true
      timeout: 180

# to run this: ansible-playbook playbook.yml --tags "deploy"

- name: Destroy the infrastructure on OpenStack
  hosts: localhost
  tags: ['destroy']
  tasks: 
    - name: Destroy an instance
      openstack.cloud.server:
        state: absent
        name: server1

    - name: Destroy a security group with security group rules
      openstack.cloud.security_group:
        state: absent
        name: secgroup_1

    - name: Destroy a security group with security group rules
      openstack.cloud.security_group:
        state: absent
        name: secgroup_2

    - name: Destroy port
      openstack.cloud.port:
        state: absent 
        name: port_server_1

    - name: Destroy port
      openstack.cloud.port:
        state: absent 
        name: port_server_2

    - name: Destroy router
      openstack.cloud.router:
        state: absent
        name: router1

    - name: Destroy subnet
      openstack.cloud.subnet:
        state: absent
        network_name: network1
        name: subnet1

    - name: Destroy network
      openstack.cloud.network:
        state: absent
        name: network1

    # when: global_instance is defined and not global_instance.failed
     # The above line is needed to check whether the instance exists before trying to delete it, however as said
     # below the global instance variable is not defined, thus this should be fixed. Without this line this play
     # fullfils his tasks and successfully deletes the vm

# to run this: ansible-playbook playbook.yml --tags "destroy" 
# The global_instance variable is not defined within this playbook, so I'm not able to automate the destruction
# of the vm

- name: Retrieve network and security group information
  hosts: localhost
  tags: ['information_details']
  tasks:
  - name: Get network details
    openstack.cloud.networks_info:
      name: MySecondNetwork
    register: network_details

# security_group and security_group_info modules handle security groups
# whereas security_group_rule and security_group_rule_info modules handle security groups' rules (thus, in this case the security group should already be existing)
  - name: Get security group details
    openstack.cloud.security_group_info: # print each security group
    register: security_group_details

  - name: Get information about server
    openstack.cloud.server_info:
      #name: MyThirdServer #print each server
    register: server_details
  
  - name: Get information about subnet
    openstack.cloud.subnets_info:
      name: cc518030-1241-4d1a-ba60-ffd73772647c
    register: subnet_details

  - name: Print network details
    debug:
      msg: "{{ network_details }}"

  - name: Print security group details
    debug:
      msg: "{{ security_group_details }}"

  - name: Print server details
    debug:
      msg: "{{ server_details }}"

  - name: Print subnet details
    debug:
      msg: "{{ subnet_details }}"


    # When you register the result of a task using the register keyword, you create a variable that holds 
    # information about the task's execution, including its output. In your playbook, the register: instance 
    # line in the "Deploy an instance" task stores the result of that task in a variable named instance.

    # When you use register, you create a variable that contains various attributes, including:
    # instance.stdout: Standard output of the task.
    # instance.stderr: Standard error of the task.
    # instance.rc: Return code of the task.
    # instance.changed: Whether the task made any changes.
    # instance.failed: Whether the task failed.

    # The instance variable is defined only after the task "Deploy an instance" has been executed. 
    # So, in the subsequent task "Destroy the instance", instance is defined checks if the instance variable exists.
    # If it does, it means the "Deploy an instance" task has been executed.
    # The instance|success condition checks whether the "Deploy an instance" task was successful. 
    # It's a shorthand way of checking if the task completed successfully (i.e., instance.failed is false).


  