#- name: Provision an instance on OpenStack # for some reason the floating ip is assigned automatically with this task
#  hosts: localhost
#  tags: ['deploy']
#  tasks:
## Remember to restart the vm if you change any environment variables
#  - name: Deploy an instance
#    openstack.cloud.server:
#      state: present
#      #cloud: mycloud
#      name: webserver
#      image: db1bc18e-81e3-477e-9067-eecaa459ec33
#      key_name: MySecondKey
#      timeout: 200
#      flavor: gx1.2c4r
#      network: MySecondNetwork
#      security_groups: default
#    register: instance
 # - include_vars: instance-vars.yml
 # - name: Debug global_instance
 #   debug:
 #     var: global_instance
 # - name: Set instance fact
 #   set_fact:
 #     global_instance: "{{ instance }}"
 #   when: instance is defined and not instance.failed
 # - name: Debug global_instance again
 #   debug:
 #     var: global_instance#

# to run this: ansible-playbook playbook.yml --tags "deploy"

- name: Creation of a security group rule
  hosts: localhost
  tags: ['security_group']
  tasks:
  - name: Create a new security group rule
    openstack.cloud.security_group:
      state: present
      name: port80_exposed
      security_group_rules:
        - ether_type: IPv4
          direction: ingress
          description: expose port 80
          port_range_max: 80
          port_range_min: 80
          protocol: tcp
          remote_ip_prefix: 0.0.0.0/0

- name: Retrieve network and security group information
  hosts: localhost
  tags: ['information_details']
  tasks:
  - name: Get network details
    openstack.cloud.networks_info:
      name: MySecondNetwork
    register: network_details

  - name: Get security group details
    openstack.cloud.security_group_info:
      security_group: port80_exposed
    register: security_group_details

  - name: Get information about server
    openstack.cloud.server_info:
      name: MyThirdServer
    register: server_details
  
  - name: Get information about subnet
    openstack.cloud.subnets_info:
      name: cc518030-1241-4d1a-ba60-ffd73772647c
    register: subnet_details

  - name: Print network details
    debug:
      msg: "{{ network_details }}"

  - name: Print security group details
    debug:
      msg: "{{ security_group_details }}"

  - name: Print server details
    debug:
      msg: "{{ server_details }}"

  - name: Print subnet details
    debug:
      msg: "{{ subnet_details }}"


    # When you register the result of a task using the register keyword, you create a variable that holds 
    # information about the task's execution, including its output. In your playbook, the register: instance 
    # line in the "Deploy an instance" task stores the result of that task in a variable named instance.

    # When you use register, you create a variable that contains various attributes, including:
    # instance.stdout: Standard output of the task.
    # instance.stderr: Standard error of the task.
    # instance.rc: Return code of the task.
    # instance.changed: Whether the task made any changes.
    # instance.failed: Whether the task failed.

    # The instance variable is defined only after the task "Deploy an instance" has been executed. 
    # So, in the subsequent task "Destroy the instance", instance is defined checks if the instance variable exists.
    # If it does, it means the "Deploy an instance" task has been executed.
    # The instance|success condition checks whether the "Deploy an instance" task was successful. 
    # It's a shorthand way of checking if the task completed successfully (i.e., instance.failed is false).


#- name: Destroy the instance on OpenStack
#  hosts: localhost
#  tags: ['destroy']
#  tasks: 
#    - include_vars: instance-vars.yml
#    - name: Debug global_instance
#      debug:
#        var: global_instance
#    - name: Destroy an instance
#      openstack.cloud.server:
#        state: absent
#        name: webserver
#      # when: global_instance is defined and not global_instance.failed
      # The above line is needed to check whether the instance exists before trying to delete it, however as said
      # below the global instance variable is not defined, thus this should be fixed. Without this line this play
      # fullfils his tasks and successfully deletes the vm

# to run this: ansible-playbook playbook.yml --tags "destroy" 
# The global_instance variable is not defined within this playbook, so I'm not able to automate the destruction
# of the vm


  